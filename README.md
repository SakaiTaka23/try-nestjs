# try-nestjs

- [try-nestjs](#try-nestjs)
- [First steps](#first-steps)
  - [ディレクトリ構成](#ディレクトリ構成)
- [Controllers](#controllers)
  - [リクエストオブジェクト](#リクエストオブジェクト)
  - [リソース](#リソース)
  - [ステータスコード](#ステータスコード)
  - [パラメーター](#パラメーター)
  - [スコープ](#スコープ)
  - [リクエストペイロード](#リクエストペイロード)
  - [動かす](#動かす)
- [Providers](#providers)
  - [サービス](#サービス)
  - [スコープ](#スコープ-1)
  - [プロパティインジェクション](#プロパティインジェクション)
  - [DI](#di)
- [Modules](#modules)
  - [フィーチャーモジュール](#フィーチャーモジュール)
  - [モジュールの共有](#モジュールの共有)
  - [グローバルモジュール](#グローバルモジュール)


# First steps



## ディレクトリ構成

| ファイル              | 用途                             |
| --------------------- | -------------------------------- |
| app.controller.ts     | ルートが記述されたコントローラー |
| app.contoller.spec.ts | コントローラーのユニットテスト   |
| app.module.ts         | ルートモジュール                 |
| app.service.ts        | サービスを記述するところ         |
| main.ts               | エントリーポイント               |



# Controllers

役割

- リクエストを処理してクライアントにレスポンスを返す
- 特定のリクエストを受け取る

- コントローラーを作るためにクラスとデコレーターを使用する
- デコレーター クラスに必要なメタデータを入れてNestにルーティングをさせる

- コントローラーには@Controller()デコレーターを使用する
- デコレーターにより繰返しの記述を減らすことができるよ

- コントローラーの生成
```
nest g controller controllername
```

- 生成されるルートに関してそのメソッドコントローラーの名前となる
- Getデコレーターに引数を渡すのその値がルートに追加される
- コントローラーに対する関数の名前は完全に任意

- Nestは基本的にコントローラーから返された値をレスポンスとする
- オブジェクトを返すと自動的にJSONに変換される
- JSの基本の型を返すとそのまま返す

- ステータスコードに関して
- 基本的には200を返す
- **POSTはデフォルトが201**となる
- デコレーターで変更可能



## リクエストオブジェクト

- リクエストの内容を受け取るには@Req()デコレーターを使用する
- デコレーターでリクエスト・レスポンス・パラメーター・ヘッダーあたりの基本的な要素は取得可能



## リソース

- 全てのメソッドに対してデコレーターがある
- @All()で全てのメソッドを受け取れるよ

## ステータスコード
- ステータスコードの変更
- 状態によって変わるレスポンスでステータスコードの変更は@Res()をインジェクトして変更？



## パラメーター

- @Paramデコレーターを使うとパラメーターの取得が可能
- デコレーターに引数を渡すと取得後のパラメーターをとってくれる



## スコープ

- Nestでは全ての情報がリクエスト同士で共有されている
- データベースへのコネクション・シングルトンサービスなど
- ただシングルスレッドで動くから安全？





## リクエストペイロード

- リクエストの型定義にはクラスを定義することを推奨する
- コンパイル時の挙動が理由



## 動かす

- コントローラーを動かすときにはmodueleの中に含める必要がある
- コマンドで生成していたので自動的に入れてくれていた



# Providers

- Nestの基本的なコンセプト
- プロパイダは依存されるものとして注入される
  - オブジェクト同士でさまざまな関係を作ることができる
- プロパイダ モジュール内でプロパイダとして定義されているJSのクラス



## サービス

- サービスはデータストレージと検索を担っている
- 特定のコントローラーに使われるためプロパイダとして良い

- 生成コマンド
```
nest g service servicename
```
- サービスには@Injectable()デコレーターを使用する
- Nest IoC containerによって管理されることを示す
- サービスはコントローラーのクラスにコンストラクタ内でインスタンス化され使用可能
- コンストラクタ内でサービスはプライベートとする



## スコープ

- 基本的にアプリケーションが立ち上がると全ての依存が解決される
  - プロパイダはインスタンス化される
- アプリケーションが閉じられると全て破壊される
- リクエスト時にインスタンス化されるようにすることもできる
  



## プロパティインジェクション

- プロパティインジェクションも可能
- 基本的にはコンストラクタでしよう



## DI

- DIを有効にするにはモジュールのプロパイダ欄にサービスを登録する
- コマンドによって生成した場合自動的に登録される



# Modules

- モジュールは@Module()デコレーターを使用することで表現できる
- 全てのアプリケーションは少なくともroot moduleが存在する
- root module スターティングポイント
- root moduleだけでも動くがコンポーネントの効率的な管理のために増やしていく方が良い
  - 基本的にアプリケーションには複数のモジュールが存在する

モジュールデコレーターが受け取るオブジェクト

| オブジェクト | 役割                                     |
| ------------ | ---------------------------------------- |
| providers    | モジュール内で共有されるべきプロパイダー |
| controllers  | インスタンスをするべきコントローラー     |
| imports      | モジュール内で必要になるモジュール       |
| export       | 他のモジュールでも使用したいもの         |

- デフォルトではモジュールはプロパイダをカプセル化する
- モジュールの一部でない or importされたモジュールに入っていないプロパイダを注入するのは不可能



## フィーチャーモジュール
- コントローラーとサービスが同じドメインに依存している場合feature moduleにするべき
- feature module 特定の機能のためにコードの関連づけを行いコードをきれいにする
- SOLID原則に基づいて開発できる



## モジュールの共有
- Nest ではデフォルトでモジュールがシングルトンとなっている
- 複数のモジュール間で同じインスタンスの共有を行うことができる
- モジュール間でのサービスの共有はモジュールのexportsにそのサービスを入れると可能
- インポートしたものをエクスポートすることも可能



## グローバルモジュール
- 頻繁にimportされるモジュールはグローバルスコープにすることが可能
- @Global()デコレーターを使用
- グローバルになりうるもの
  - ヘルパー
  - データベースのコネクション
  - など
- モジュールないのimportsに入れなくても取り入れることが可能

