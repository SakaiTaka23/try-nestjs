# try-nestjs

- [try-nestjs](#try-nestjs)
- [First steps](#first-steps)
  - [ディレクトリ構成](#ディレクトリ構成)
- [Controllers](#controllers)
  - [リクエストオブジェクト](#リクエストオブジェクト)
  - [リソース](#リソース)
  - [ステータスコード](#ステータスコード)
  - [パラメーター](#パラメーター)
  - [スコープ](#スコープ)
  - [リクエストペイロード](#リクエストペイロード)
  - [動かす](#動かす)
- [Providers](#providers)
  - [サービス](#サービス)
  - [スコープ](#スコープ-1)
  - [プロパティインジェクション](#プロパティインジェクション)
  - [DI](#di)
- [Modules](#modules)
  - [フィーチャーモジュール](#フィーチャーモジュール)
  - [モジュールの共有](#モジュールの共有)
  - [グローバルモジュール](#グローバルモジュール)
- [Middleware](#middleware)
  - [ミドルウェアの適用](#ミドルウェアの適用)
  - [関数ミドルウェア](#関数ミドルウェア)
  - [グローバルミドルウェア](#グローバルミドルウェア)
- [Exception filters](#exception-filters)
  - [基本的なエラーを返す](#基本的なエラーを返す)
- [Pipes](#pipes)
  - [組み込みのパイプ](#組み込みのパイプ)
  - [パイプの使用](#パイプの使用)
  - [カスタムパイプ](#カスタムパイプ)


# First steps



## ディレクトリ構成

| ファイル              | 用途                             |
| --------------------- | -------------------------------- |
| app.controller.ts     | ルートが記述されたコントローラー |
| app.contoller.spec.ts | コントローラーのユニットテスト   |
| app.module.ts         | ルートモジュール                 |
| app.service.ts        | サービスを記述するところ         |
| main.ts               | エントリーポイント               |



# Controllers

役割

- リクエストを処理してクライアントにレスポンスを返す
- 特定のリクエストを受け取る

- コントローラーを作るためにクラスとデコレーターを使用する
- デコレーター クラスに必要なメタデータを入れてNestにルーティングをさせる

- コントローラーには@Controller()デコレーターを使用する
- デコレーターにより繰返しの記述を減らすことができるよ

- コントローラーの生成
```
nest g controller controllername
```

- 生成されるルートに関してそのメソッドコントローラーの名前となる
- Getデコレーターに引数を渡すのその値がルートに追加される
- コントローラーに対する関数の名前は完全に任意

- Nestは基本的にコントローラーから返された値をレスポンスとする
- オブジェクトを返すと自動的にJSONに変換される
- JSの基本の型を返すとそのまま返す

- ステータスコードに関して
- 基本的には200を返す
- **POSTはデフォルトが201**となる
- デコレーターで変更可能



## リクエストオブジェクト

- リクエストの内容を受け取るには@Req()デコレーターを使用する
- デコレーターでリクエスト・レスポンス・パラメーター・ヘッダーあたりの基本的な要素は取得可能



## リソース

- 全てのメソッドに対してデコレーターがある
- @All()で全てのメソッドを受け取れるよ

## ステータスコード
- ステータスコードの変更
- 状態によって変わるレスポンスでステータスコードの変更は@Res()をインジェクトして変更？



## パラメーター

- @Paramデコレーターを使うとパラメーターの取得が可能
- デコレーターに引数を渡すと取得後のパラメーターをとってくれる



## スコープ

- Nestでは全ての情報がリクエスト同士で共有されている
- データベースへのコネクション・シングルトンサービスなど
- ただシングルスレッドで動くから安全？





## リクエストペイロード

- リクエストの型定義にはクラスを定義することを推奨する
- コンパイル時の挙動が理由



## 動かす

- コントローラーを動かすときにはmodueleの中に含める必要がある
- コマンドで生成していたので自動的に入れてくれていた



# Providers

- Nestの基本的なコンセプト
- プロパイダは依存されるものとして注入される
  - オブジェクト同士でさまざまな関係を作ることができる
- プロパイダ モジュール内でプロパイダとして定義されているJSのクラス



## サービス

- サービスはデータストレージと検索を担っている
- 特定のコントローラーに使われるためプロパイダとして良い

- 生成コマンド
```
nest g service servicename
```
- サービスには@Injectable()デコレーターを使用する
- Nest IoC containerによって管理されることを示す
- サービスはコントローラーのクラスにコンストラクタ内でインスタンス化され使用可能
- コンストラクタ内でサービスはプライベートとする



## スコープ

- 基本的にアプリケーションが立ち上がると全ての依存が解決される
  - プロパイダはインスタンス化される
- アプリケーションが閉じられると全て破壊される
- リクエスト時にインスタンス化されるようにすることもできる
  



## プロパティインジェクション

- プロパティインジェクションも可能
- 基本的にはコンストラクタでしよう



## DI

- DIを有効にするにはモジュールのプロパイダ欄にサービスを登録する
- コマンドによって生成した場合自動的に登録される



# Modules

- モジュールは@Module()デコレーターを使用することで表現できる
- 全てのアプリケーションは少なくともroot moduleが存在する
- root module スターティングポイント
- root moduleだけでも動くがコンポーネントの効率的な管理のために増やしていく方が良い
  - 基本的にアプリケーションには複数のモジュールが存在する

モジュールデコレーターが受け取るオブジェクト

| オブジェクト | 役割                                     |
| ------------ | ---------------------------------------- |
| providers    | モジュール内で共有されるべきプロパイダー |
| controllers  | インスタンスをするべきコントローラー     |
| imports      | モジュール内で必要になるモジュール       |
| export       | 他のモジュールでも使用したいもの         |

- デフォルトではモジュールはプロパイダをカプセル化する
- モジュールの一部でない or importされたモジュールに入っていないプロパイダを注入するのは不可能



## フィーチャーモジュール
- コントローラーとサービスが同じドメインに依存している場合feature moduleにするべき
- feature module 特定の機能のためにコードの関連づけを行いコードをきれいにする
- SOLID原則に基づいて開発できる



## モジュールの共有
- Nest ではデフォルトでモジュールがシングルトンとなっている
- 複数のモジュール間で同じインスタンスの共有を行うことができる
- モジュール間でのサービスの共有はモジュールのexportsにそのサービスを入れると可能
- インポートしたものをエクスポートすることも可能



## グローバルモジュール
- 頻繁にimportされるモジュールはグローバルスコープにすることが可能
- @Global()デコレーターを使用
- グローバルになりうるもの
  - ヘルパー
  - データベースのコネクション
  - など
- モジュールないのimportsに入れなくても取り入れることが可能



# Middleware
- ミドルウェアはルートハンドラーの前に呼ばれる関数
- リクエストとレスポンスオブジェクトにアクセス可能
- デフォルトではexpressのミドルウェアと同じ

- ミドルウェアの実装をするときは@Injectable()デコレーターが必要
- NestMiddlewareインターフェースを実装するべき
  - このインターフェースは特に必要なものはない

- ミドルウェアのIDはコンストラクタで行う



## ミドルウェアの適用
- モジュールのクラス内でconfigure関数を使うことによって使用する
- apply時に複数指定するとその分だけ通すことができる
- forRoutesによって適用範囲を特定のルートや特定のメソッド・コントローラーに対して行うことができる
- excludeによって適用を省くことができる



## 関数ミドルウェア
- ミドルウェアはクラスでも関数でも定義することができる
- 中に関数がない場合は依存するものがない場合は関数で定義した方が良い



## グローバルミドルウェア
- main.tsに直接書くとグローバルミドルウェアにすることができる



# Exception filters
- exception filters アプリケーションを通してハンドルされていない例外を処理する
- 例外がコード上で捉えられていない場合これが働く
- 基本的にはHTTP 500を返す？



## 基本的なエラーを返す
- NestではHttpExceptionという関数がありメッセージとステータスを投げるとその値を返す
  - 引数 メッセージ・ステータスコード

- メッセージをオブジェクトにすると追加のメッセージを入れることができる

- Exception filters自体そのまま使っても特に問題はなさそう



# Pipes
- @Injectable()デコレーターを使用する
- PipeTransformインターフェースを継承する

**使い道**
- transformation インプットデータを正しい型に変換する(string → integer)
- validation 満たしていればそのまま返す 満たしていなければエラーを返す

- コントローラーへの引数に対して行われている
- Nestは関数が実行される前にパイプを通す



##  組み込みのパイプ
- ValidationPipe
- ParseIntPipe
- ParseFloatPipe
- ParseBoolPipe
- ParseArrayPipe
- ParseUUIDPipe
- ParseEnumPipe
- DefaultValuePipe



## パイプの使用
- コントローラーの引数でパイプを使うと使用することができる


## カスタムパイプ
- パイプは自作も可能
  

